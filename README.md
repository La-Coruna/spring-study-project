# jpa 공부를 위한 프로젝트

## 📆 진행 기록 (Progress Timeline)
- 2025-07-06
  - 스프링 부트 프로젝트 생성 (start.spring.io 사용)
  - view, controller 테스트
  - h2 db 설치
- 2025-07-10
  - 엔티티 설계

## 📘 Key Learnings
- **JPA 개념**
  - JPA(Java Persistence API)는 객체와 관계형 데이터베이스 간의 패러다임 불일치를 해결하기 위한 ORM(Object-Relational Mapping) 표준 인터페이스이다.
  ![객체와 테이블의 연관관계 관점.png](docs/images/객체와 테이블의 연관관계 관점.png)
- 영속성(Persistence)
  - 영속성 컨텍스트(persistence context)는 '엔티티를 영구 저장하는 환경'이다.
  - 엔티티 매니저의 `persist()` 메소드를 사용하면, 엔티티를 영속성 컨텍스트에 저장하는 것이다.
  - 보통은 엔티티 매니저당 하나의 영속성 컨텍스트가 만들어지고, 상황에 따라서 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있다.
- 엔티티의 생명주기
  - 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 영속: 영속성 컨텍스트에 저장된 상태
  - 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 삭제: 삭제된 상태
- 엔티티 맵핑 어노테이션
  - @Entity
    - JPA를 사용해서 테이블과 매핑할 클래스 지정
      - name: JPA에서 사용할 엔티티 이름. 기본값은 클래스 이름
    - 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
    - final 클래스, enum, interface, inner 클래스에는 사용 불가
    - 저장할 필드에 final을 사용하면 안됨.
  - @Table
    - 엔티티와 매핑할 테이블을 지정.
      - name: 매핑할 테이블 이름. 기본값은 엔티티 이름
      - catalog: 데이터베이스의 catalog 매핑
      - schema: 데이터베이스의 schema 매핑
      - uniqueConstraints(DDL) : DDL 생성 시, 유니크 제약조건을 만듦.

- 일대다(1:N) 양방향 관계 설정

| 항목                | 설명                                    |
| ----------------- | ------------------------------------- |
| 연관관계의 주인          | 외래 키를 가진 쪽 (DB에 실제로 반영되는 쪽)           |
| mappedBy          | 주인이 **아닌 쪽**이 사용. 상대편 클래스의 참조 필드명을 적음 |
| @JoinColumn(name) | 주인 쪽에서 사용. 내 테이블에 생성될 **FK 컬럼명** 지정   |
| 일대다 관계에서의 주인      | 항상 **다(N)쪽**이 주인 (외래 키를 가지기 때문)       |
| FK가 N쪽에 있는 이유     | 1NF 위반 방지, 현실 모델링과 일치, 성능 및 관리 용이성    |

- 다대다(N:N) 관계에서 `@ManyToMany`로 설정시 `@JoinTable` 내부 속성 의미
  - 실무에서는 `@ManyToMany`를 쓰지 말자
  - `@ManyToMany`에서는 fetch 기본값이 LAZY이다.
    | 속성명                  | 설명                             |
    | -------------------- | ------------------------------ |
    | `name`               | 중간 테이블 이름                      |
    | `joinColumns`        | **내 쪽(FK)** 설정 (`@JoinColumn`) |
    | `inverseJoinColumns` | **상대쪽(FK)** 설정 (`@JoinColumn`) |


- CascadeType.ALL

| 항목                | 설명                                  |
| ----------------- | ----------------------------------- |
| `CascadeType.ALL` | 저장, 삭제, 병합 등 모든 작업을 전파              |
| 언제 사용?            | 자식 엔티티의 생명주기가 부모에 종속될 때             |
| 언제 피해야 하나?        | 자식이 여러 곳에서 공유되는 경우 (예: 공통 코드, 유저 등) |
| 기본값               | cascade는 기본적으로 설정되지 않음 (직접 명시 필요)   |

- InheritanceType 전략 종류

| 전략                | 설명                         | 특징                              |
| ----------------- | -------------------------- | ------------------------------- |
| `SINGLE_TABLE`    | 하나의 테이블에 모든 자식 클래스 데이터를 저장 | ✅ 성능 좋음, 구조 단순<br>❌ null 컬럼 많아짐 |
| `JOINED`          | 부모/자식 각각 테이블 생성 + 조인       | ✅ 정규화됨<br>❌ 조인 많아져서 성능 낮음       |
| `TABLE_PER_CLASS` | 자식 클래스마다 테이블 따로 생성         | ❌ 잘 안 씀 (조회 비효율적)               |

 
## 💡 Useful Tips
- **엔티티 매니저**
  - 엔티티 매니저는 만드는 비용이 상당히 크다. -> 한 개만 만들어서 어플리케이션 전체에서 공유하도록 설계.
  - 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.
  - 근데, 결국 스프링 부트가 엔티티 팩토리 생성과 엔티티 매니저 생성을 다 알아서 해주게 된다... 이 얼마나 편한 세상...
- **연관관계**
  - 외래 키가 있는 곳을 연관관계의 주인으로 정해라.
    - ex) 자동차와 바퀴에서는 바퀴를 연관관계의 주인으로.
- JPA에서 @ManyToOne, @OneToOne은 기본이 EAGER라서 반드시 LAZY로 명시적으로 바꿔야 함!
  즉시 로딩은 관계가 복잡할수록 쿼리 폭발의 원인이 됨
  ``` java 
  @ManyToOne(fetch = FetchType.LAZY) // 👍 명시적으로 설정 추천!
  private Team team;
  ```
- 엔티티 설계시 주의사항
  - 엔티티에는 가급적 Setter를 사용하지 말자
    - setter가 모두 열려있다면 변경포인트가 너무 많아서 유지 보수가 어렵다. 리팩토링으로 Setter를 제거하자.
  - 모든 연관관계는 지연로딩으로 설정하자
    - 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기도 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
    - 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다.
    - 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
    - @XToOne(OneToOne,ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정헤야 한다.
  - 컬렉션은 필드에서 초기화 하자
    - null 문제에서 안전해진다.
    - 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트의 내장 컬렉션으로 변경한다. 따라서 하이버네이트 내부 메커니즘과 꼬이지 않게, 필드 레벨에서 생성하는 것이 가장 안전하고 코드도 간결하다.
  - 스프링 부트에서 하이버네이트 기본 매핑 전략을 변경해서, 실제 테이블 필드명은 다르다.
  

- 왜 Date는 이제 잘 안 쓰는가

| `java.util.Date`    | `java.time.LocalDateTime` |
|---------------------| ------------------------- |
| 값 변경 가능 (mutable)   | 불변 객체                     |
| API가 불편함            | 가독성 좋고 체계적                |
| 시간대 개념이 섞여 있음       | 시간대 없음 (명확함)              |
| 혼란 유발 (월이 0부터 시작 등) | 직관적                       |
| @Temporal 필수 | @Temporal 없이도 TIMESTAMP 컬럼으로 자동 매핑 |

- `@Enumerated(EnumType.STRING)의 장점`
  - enum 순서가 바뀌거나 중간에 값이 추가되어도 전혀 문제 없음
  - 가독성도 좋고, 안전성도 높음

- 연관관계 편의 메서드
  - 편의 메서드(연관관계 메서드)를 어디에 둘지는 **연관관계의 주인 여부와는 별개**로 **객체 구조와 의미**를 기준(부모냐 자식이냐, 사용 흐름 등)으로 판단한다.
- 임베디드 타입(@Embeddable)은 자바 기본 생성자를 public 또는 protected로 설정해야 한다. public 보다는 protected가 그나마 더 안전.

